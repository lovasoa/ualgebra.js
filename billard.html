<html>
<head>
<title>Linear algebra test</title>
<script src="ualgebra.js"></script>

<style>
canvas {
	background-color:white;
}
body {
	background-color:black;
}
</style>

</head>

<body>

<canvas id="billardCanvas" width="1000" height="500"><h1>Installez Mozilla Firefox</h1></canvas>

<script>

var canvas = document.getElementById("billardCanvas");
var ctx = canvas.getContext('2d');

ctx.setTransform(2,0,0,-2,canvas.width/2, canvas.height/2);
//drawStandardBasis();


Billard = function (x, y, dx, dy, domain) {
	this.domain = domain;
	this.x = x;
	this.y = y;
	this.dx = dx;
	this.dy = dy;
	this.points = [];
	this.derivs = [];
	this.res = 100;

	this.draw  = function (resolution) {
		if (resolution) this.res=resolution;
		blank(ctx);
		this.points = new Array(this.res);
		this.derivs = new Array(this.res);
		var a = this.domain[0], b = this.domain[1];
		var step = (b - a)/this.res;
		ctx.beginPath();
		for (var i=0; i<this.res; i++){
			var t = a+i*step;
			var x = this.x(t);
			var y = this.y(t);
			ctx.lineTo(x, y);
			this.points[i] = [x, y];
			this.derivs[i] = [this.dx(t), this.dy(t)];
		}
		ctx.closePath();
		ctx.stroke();
	}
};

/*returns the coordinates of the point of intersection of the segments
formed by the couple of points (a1,a2) and (b1,b2)*/
function segmentIntersection (a1, a2, b1, b2) {
	var min = Math.min, max = Math.max;
	var axmax = max(a1[0], a2[0]), bxmax = max(b1[0], b2[0]);
	var aymax = max(a1[1], a2[1]), bymax = max(b1[1], b2[1]);
	var axmin = min(a1[0], a2[0]), bxmin = min(b1[0], b2[0]);
	var aymin = min(a1[1], a2[1]), bymin = min(b1[1], b2[1]);
	if ( axmax < bxmin || bxmax < axmin || aymax < bymin || bymax < aymin) {
		return null;
	}
	var x, y;

	var slopea = (a2[1]-a1[1])/(a2[0]-a1[0]);
	var slopeb = (b2[1]-b1[1])/(b2[0]-b1[0]);

	if (Math.abs(slopea)===Math.abs(slopeb)) {
		if (Math.abs((b1[1]-a1[1])/(b1[0]-a1[0])) !== Math.abs(slopea)) return null;
		x = (min(axmax,bxmax)+max(axmin,bxmin))/2;
		y = (min(axmax,bxmax)+max(axmin,bxmin))/2;
	} else if (slopea === Infinity) {
		x = a1[0];
		y = b1[1] + (x-b1[0]) * slopeb;
	} else if (slopeb === Infinity) {
		x = b1[0];
		y = a1[1] + (x-a1[0]) * slopea;
	} else {
		x = (b1[1] - a1[1] + a1[0]*slopea - b1[0]*slopeb)/(slopea-slopeb);
		y = a1[1] + (x-a1[0]) * slopea;
	}
	if ( x > min(axmax,bxmax) || x < max(axmin,bxmin) || y > min(aymax,bymax) || y < max(aymin,bymin)) {
		return null;
	} else {
		return [x, y];
	}
}

function blank(ctx) {
		var w = ctx.canvas.width;
		var h = ctx.canvas.height;
		ctx.clearRect(-w/2, -h/2, w, h);
}


var Ellipse = new Billard (
				function (t) { return 150*Math.cos(t); }, //x
				function (t) { return 50*Math.sin(t); }, //y
				function (t) { return -150*Math.sin(t); }, //dx
				function (t) { return 50*Math.cos(t); }, //dy
				[0, 2*Math.PI] //Domain
				);
var billard = Ellipse;

Boule = function (x,y,dx,dy) {
	this.x = x;
	this.y = y;
	this.dx = dx;
	this.dy = dy;
	this.radius = 1;
	this.draw = function () {
		ctx.beginPath();
		ctx.arc(this.x, this.y, this.radius, 0, 2*Math.PI);
		ctx.fill();
	}
	this.update = function () {
		var b1 = [this.x, this.y];
		var b2 = [this.x+this.dx, this.y+this.dy];
		ctx.fillRect(b1[0]-1, b1[1]-1, 2, 2);
		ctx.fillRect(b2[0]-1, b2[1]-1, 2, 2);

		for (var i=0; i<billard.res; i++) {
			var point = billard.points[i];
			var point2 = billard.points[(i+1)%billard.res];
			inter = segmentIntersection(b1, b2, point, point2);
			if (inter) {
				var deriv = billard.derivs[i];
				var norm = Math.sqrt(deriv[0]*deriv[0] + deriv[1]*deriv[1]);
				deriv = [deriv[0]/norm, deriv[1]/norm];
				var scalarprod = this.dx*deriv[0] + this.dy*deriv[1];
				var proj = [deriv[0]*scalarprod, deriv[1]*scalarprod];
				this.dx = 2*proj[0]-this.dx;
				this.dy = 2*proj[1]-this.dy;
				this.x = inter[0];
				this.y = inter[1];
				break;
			}
		}
		this.x += this.dx;
		this.y += this.dy;
		this.draw();
	}
};
var boule = new Boule(0,0,3,2);


window.requestAnimFrame = (function(){
    return window.requestAnimationFrame       || // La forme standardisée
           window.webkitRequestAnimationFrame || // Pour Chrome et Safari
           window.mozRequestAnimationFrame    || // Pour Firefox
           window.oRequestAnimationFrame      || // Pour Opera
           window.msRequestAnimationFrame     || // Pour Internet Explorer
           function(callback){                   // Pour les élèves du dernier rang
               window.setTimeout(callback, 1000 / 60);
           };
})();

function animate() {
	boule.update();
	window.requestAnimFrame(animate);
}
billard.draw();
animate();

function Bench (res) {
	var t = new Date();
	billard.draw(res);
	return ((new Date()) - t);
}

function cartesian2polar (x, y) {
	var r = Math.sqrt(x*x + y*y);
	var theta = ((x<0)?Math.PI:0) + Math.atan(y/x);
	return [r, theta];
}

function polar2cartesian (r, theta) {
	var x = r * Math.cos(theta);
	var y = r * Math.sin(theta);
	return [x, y];
}

function  drawStandardBasis () {
	ctx.fillStyle = "rgba(200,80,80,0.8)";
	ctx.beginPath();
	ctx.moveTo(0,0);
	ctx.lineTo(50, 0);
	ctx.moveTo(0,0);
	ctx.lineTo(0,50);
	ctx.stroke();
	ctx.fillText("Y (0,50)", 0,50);
	ctx.fillText("X (50,0)", 50,0);
}

</script>

</body>

</html>
